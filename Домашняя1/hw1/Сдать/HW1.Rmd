---
title: "Домашняя работа 1"
author: "Сопова Екатерина, РИ-450004"
date: '7 ноября 2018 г '
output: html_document
---

По адресу http://people.math.umass.edu/~anna/Stat597AFall2016/rnf6080.dat можно получить набор данных об осадках в Канаде с 1960 по 1980 годы. Необходимо загрузить эти данные при помощи ``read.table``. Воспользуйтесь справкой, чтобы изучить аргументы, которые принимает функция. 
- Загрузите данные в датафрейм, который назовите ``data.df``.
```{r}
data.df<-read.table(file="http://people.math.umass.edu/~anna/Stat597AFall2016/rnf6080.dat")
```

- Сколько строк и столбцов в ``data.df``? Если получилось не 5070 наблюдений 27 переменных, то проверяйте аргументы.
```{r}
nrow(data.df)
ncol(data.df)
```

- Получите имена колонок из ``data.df``.
```{r}
colnames(data.df)
```

- Найдите значение из 5 строки седьмого столбца.
```{r}
data.df[5,7]
```

- Напечатайте целиком 2 строку из ``data.df``
```{r}
data.df[2,]
```

- Объясните, что делает следующая строка кода ``names(data.df) <- c("year", "month", "day", seq(0,23))``. Воспользуйтесь функциями ``head`` и ``tail``, чтобы просмотреть таблицу. Что представляют собой последние 24 колонки?
```{r}
names(data.df) <- c("year", "month", "day", seq(0,23))
head(data.df)
tail(data.df)
```

Последние 24 колонки представляют из себя часы, то есть в эти часы занасились сведения об осадках.

- Добавьте новую колонку с названием *daily*, в которую запишите сумму крайних правых 24 колонок. Постройте гистограмму по этой колонке. Какие выводы можно сделать?
```{r}
daily<-c(rowSums(data.df[4:27]));
data.df<-cbind(data.df,daily=daily);
hist(data.df[,"daily"], prob = TRUE, main = "Гистограмма ежедневных осадков в Канаде",ylab="Плотность",xlab="Количество осадков (мм)")
```

По данной гистограмме нельзя понять о количестве ежедневных осаков, так как среди значений daily встречаются отрицательные значения, из-за чего возникают ошибочные значания в самом датафрейме.

- Создайте новый датафрейм ``fixed.df`` в котром исправьте замеченную ошибку. Постройте новую гистограмму, поясните почему она более корректна.
```{r}
fixed.df<-as.data.frame(data.df);
fixed.df[fixed.df[,]<0]<-0;
hist(fixed.df[,"daily"], prob = TRUE, main = "Гистограмма ежедневных осадков в Канаде",ylab="Плотность",xlab="Количество осадков (мм)")
```

По данной гистограмме можно сделать выводы о ежедневных осадках, так как отсутствуют отрицательные значения.

## Синтаксис и типизирование
* Для каждой строки кода поясните полученный результат, либо объясните почему она ошибочна.
```{r}
v <- c("4", "8", "15", "16", "23", "42")#создание вектора, в котором находяться символы-char
max(v)#выводит максимальное значение символьного вектора,а так как производиться посимвольное сравнене, то поэтому выводиться "8"
sort(v)#выполняет сортировку вектора. Так же посимвольно и подверрждает предыдущую команду.
#sum(v)#данная команда ошибочна, та как вектор считается чаровым, а это команда суммирует числовые, комплексные и логические аргументы.
```


* Для следующих наборов команд поясните полученный результат, либо объясните почему они ошибочна.

```{r}
v2 <- c("5",7,12)#создается вектор. Так как первым заноситься символьный элемент, то и из-за него определяется тип вектора для всех последующих элементов
#v2[2] + v2[3]#операция ошибочна, так как вектор символьный

df3 <- data.frame(z1="5",z2=7,z3=12)#создается датафоейм, в который заносятся элементы вектора с сохранением их первоначальных типов
df3[1,2] + df3[1,3]#в этом случае происходит суммирование элементов датафрейма

l4 <- list(z1="6", z2=42, z3="49", z4=126)#создание списка из четырех элементов. В отличие от векторов в списке можно хранить одновременно различные типы данных. В список помещаются отдельные компоненты, а уже внутри этих компонентов располагаются сами элементы определенных типов, внесенные в список.
l4[[2]] + l4[[4]]#происходит суммирование элементов, так как при помощи двойных квадратных скобок список извлекает элементов списка
#l4[2] + l4[4]#операция ошибочна так как одиночые квадратные скобки возвращают только ссылку на элемент списка, а не на само значение
```


## Работа с функциями и операторами
* Оператор двоеточие создаёт последовательность целых чисел по порядку. Этот оператор — частный случай функции ``seq()``, которую вы использовали раньше. Изучите эту функцию, вызвав команду ``?seq``. Испольуя полученные знания выведите на экран:
    1. Числа от 1 до 10000 с инкрементом 372. 
    1. Числа от 1 до 10000 длиной 50.
```{r}
seq(1,10000,by=372)
seq(1,10000,length.out = 50)
```
    
* Функция ``rep()`` повторяет переданный вектор указанное число раз. Объясните разницу между ``rep(1:5,times=3)`` и ``rep(1:5, each=3)``.
```{r}
rep(1:5,times=3)#при использовании times данный вектор повторяется три раза
rep(1:5,each=3)#при использовании each каждый элемент подряд повторяется три раза
```

